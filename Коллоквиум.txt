Лу Тимур 5 группа
1)ООП — это одна из парадигм разработки. Парадигмой называют набор правил и критериев, которые соблюдают разработчики при написании кода.
Парадигма помогает стандартизировать написание кода. Это снижает риск ошибок, ускоряет разработку и делает код более читабельным для других программистов. Все программы, написанные с применением этой парадигмы, состоят из объектов. Каждый объект — это определённая сущность со своими данными и набором доступных действий.
Наследование: Каждый дочерний элемент наследует методы и атрибуты, прописанные в родительском. Он может использовать их все, отбросить часть или добавить новые. При этом заново прописывать эти атрибуты и методы не нужно. 
Инкапсуляция: Вся информация, которая нужна для работы конкретного объекта, должна храниться внутри этого объекта. Для внешних объектов доступны только публичные атрибуты и методы. 
Полиморфизм: Один и тот же метод может работать по-разному в зависимости от объекта, где он вызван, и данных, которые ему передали. 

Объектно-ориентированное программирование — это инструмент борьбы с доменной сложностью, представляющий собой способ построения программного "слоёного пирога" через принцип "разделяй и властвуй". Несмотря на теоретическую базу, сформированную 2,5 тысячи лет назад, практическое применение ООП началось лишь в 1980-е годы в ответ на принципиальное усложнение предметных областей.
 Инкапсуляция:
Средство управления сложностью через сокрытие изменчивости
Скрывает внутреннюю реализацию объектов от внешнего мира
Создает естественное противоречие: сокрытие изменчивости увеличивает локальную сложность системы, но обеспечивает глобальное упрощение
В 99% случаев приоритет отдается управлению изменчивостью, а не минимизации сложности

Наследование и Агрегация/Композиция:
Два основных средства "художественной выразительности" в ООП
Наследование — частный случай инкапсуляции
Агрегация/Композиция — более гибкий подход
Оба механизма позволяют переиспользовать и комбинировать функциональность

Полиморфизм:
Способ упрощения кода "клиента" через единый интерфейс
Вариант реализации инкапсуляции, скрывающий разнообразие конкретных реализаций
Позволяет клиентскому коду работать с абстракциями, а не с конкретными типами
Кардинально упрощает взаимодействие между компонентами системы

2)Объектно-ориентированная декомпозиция: явление, процесс представляется в виде совокупности объектов, каждый из которых является абстракцией реальных предметов, явлений, процессов. Программа в данном случае представляет собой "жизнь" взаимодействующих между собой объектов, которые благодаря этому взаимодействию поэтапно решают поставленную задачу. Объектно-ориентированный подход позволяет решать более широкий круг задач, моделировать более сложные процессы и явления (как показывает практика из любой области человеческой деятельности.

3)Дизайн ПО — это процесс создания архитектуры и структуры программы до начала написания кода. Это как чертеж дома перед его строительством. То есть, это план того как будет устроена программа. Включает в себя: Структуру программы(из каких частей будет состоять программа, как эти части будут связаны между собой), Выбор технологий(какой язык, какие базы данных, какие библиотеки), Взаимодействие(как разные части программы будут общаться, кто за что отвечает)
Пример Мессенджер:
class User {
    string name;
    vector<Chat> chats;
};
class Chat {
    vector<User> participants;
    vector<Message> messages;
};
class Message {
    string text;
    User sender;
    DateTime time;
};

4) Кратковременная человеческая память, как правило, не может запомнить и повторить более 7 +- 2 элементов. Рекомендации: Цикломатическая сложность, в идеале, не должна превышать 5(7-2), ну 10 приемлимое число(7+2), Количество интерфейсов, которые реализует класс(желательно не больше 5), Количество методов у интерфейса(точно не больше 10), Количество слоев, Количество дизайн патернов в рамках связки для решения задачи, Ограничение основных пунктов меню до 5-7, Количество параметров в методе, Количество переменных в функции,  Количество иконок в мобильном приложении.

5) 
1. "Сложные системы часто являются иерархическими и состоят из взаимозависимых подсистем, которые в свою очередь также могут быть разделены на подсистемы, и т.д., вплоть до самого низкого уровням."
2. Выбор, какие компоненты в данной системе считаются элементарными, относительно произволен и в большой степени оставляется на усмотрение исследователя.
3. "Внутрикомпонентная связь обычно сильнее, чем связь между компонентами. Это обстоятельство позволяет отделять "высокочастотные" взаимодействия внутри компонентов от "низкочастотной" динамики взаимодействия между компонентами".
4. "Иерархические системы обычно состоят из немногих типов подсистем, по-разному скомбинированных и организованных".
5. "Любая работающая сложная система является результатом развития работавшей более простой системы... Сложная система, спроектированная "с нуля", никогда не заработает. Следует начинать с работающей простой системы".

Пример 1: Веб-браузер (Chrome)
1. Иерархичность:
Система: Браузер. Подсистемы: Движок рендеринга (Blink), JavaScript-движок (V8), сетевая подсистемка, подсистема безопасности, UI
Низший уровень: Машинные инструкции для обработки одного HTML-тега.
2. Произвольность элементарных компонентов:
Для рядового пользователя элементарный компонент — это «вкладка». Для тестировщика — HTML-элемент. Выбор зависит от задачи.

3. Сила связей:
Внутри компонента: Модули внутри движка V8 интенсивно обмениваются данными в память (высокочастотные вызовы функций при выполнении JS).
Между компонентами: Сетевой стек и движок рендеринга обмениваются относительно крупными и редкими событиями: «запрос завершен», «начать парсинг» (низкочастотная динамика).

4. Немного типов подсистем:
Типы подсистем, из которых собран браузер, повторяются: «движок исполнения кода» (V8), «движок рендеринга» (Blink), «менеджер ресурсов» (сетевой стек, кэш). Эти типы комбинируются для создания разных браузеров (Chrome, Edge, Opera).

5. Развитие из простой системы:
Первый браузер Тимом Бернерсом-Ли был простым текстовым просмотрщиком. Netscape Navigator добавил базовый JS и поддержку изображений. Современный Chrome — результат 30 лет эволюции, а не создания «с нуля» в том виде, в каком он есть сейчас.

Пример 2: Микросервисная архитектура (например, стриминговый сервис)
1. Иерархичность:
Система: Весь стриминговый сервис.
Подсистемы: Сервис рекомендаций, сервис контента, сервис пользователей.

2. Произвольность элементарных компонентов:
Для владельца продукта элементарный компонент — это «сервис». Для разработчика — это класс или функция внутри сервиса.

3. Сила связей:
Внутри компонента: Модули внутри одного сервиса (например, кэш, репозиторий, контроллер) тесно связаны через общую память и частые вызовы (высокочастотные).
Между компонентами: Сервисы общаются через API-вызовы (REST/gRPC) — это редкие, более медленные взаимодействия (низкочастотные). Сервис биллинга не «знает» о внутренней работе ML-модели в сервисе рекомендаций.

4. Немного типов подсистем:
Архитектура строится из повторяющихся типов: «CRUD-сервис» (пользователи, контент), «сервис с ML» (рекомендации). Они используют одинаковые паттерны (API Gateway, база данных, кэш), но скомбинированы по-разному.

5. Развитие из простой системы:
Сервис начинался как монолит — одно большое приложение, которое делало всё. По мере роста его разбили на несколько крупных сервисов (например, отдельно бэкенд и база данных). Затем произошла дальнейшая декомпозиция в полноценную микросервисную архитектуру. Создать такую систему сразу из сотен микросервисов невозможно.

Пример 3: Операционная система (Linux)
1. Иерархичность:
Система: ОС Linux.
Подсистемы: Ядро, подсистема ввода-вывода, файловая подсистема, сетевая подсистема, планировщик процессов.
Низший уровень: Системный вызов (например, read() или write()).

2. Произвольность элементарных компонентов:
 Для разработчика драйверов — это «модуль ядра». Для программиста на C++ — это «системная библиотека» (например, glibc).

3. Сила связей:
Внутри компонента: Модули внутри ядра (например, планировщик и менеджер памяти) интенсивно взаимодействуют через общие структуры данных в ядерной памяти (высокочастотно).
Между компонентами: Взаимодействие между ядром и пользовательским приложением происходит через системные вызовы — это четко определенный, более медленный интерфейс (низкочастотная динамика).

4. Немного типов подсистем:
Linux состоит из повторяющихся типов компонентов: «драйвер устройства» (для мыши, клавиатуры, сетевой карты), «файловая система». Принципы организации этих типов едины.

5. Развитие из простой системы:
Первый прототип Линуса Торвальдса был простым загрузчиком, который мог выводить на экран AAAAABBBBB. Он не имел ни файловой системы, ни многозадачности.